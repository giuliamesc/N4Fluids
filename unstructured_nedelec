// UNSTRUCTURED MESH, NEDELEC

int I = 6;
real [int] hvect (I);
real [int] error (I);

real a = 0;
real b = pi;

verbosity=0;
real sigma = 20; //value of the shift
int nev = 20; //number of computed eigen value close to sigma

for(int i=0; i<I; i++){
//Mesh
border l1(t=a,b){x=t;y=0;label=1;}
border l2(t=a,b){x=b;y=t;label=2;}
border l3(t=a,b){x=b-t;y=b;label=3;}
border l4(t=a,b){x=a;y=b-t;label=4;}
mesh Th=buildmesh(l1(2^(i+2))+l2(2^(i+2))+l3(2^(i+2))+l4(2^(i+2)));
plot(Th);
//Fespace
fespace Vh(Th,RT0Ortho);
Vh [u1,u2];
Vh [v1,v2];
fespace Qh(Th,P0);
Qh h = hTriangle;
hvect[i]= h[].max;
//Eigenvalue problem
// OP = A - sigma B ; // the shifted matrix
varf op([u1,u2],[v1,v2])= int2d(Th)(dx(u2)*dx(v2)-dy(u1)*dx(v2)-dx(u2)*dy(v1)+dy(u1)*dy(v1)) 
						 -int2d(Th) (sigma*u1*v1+sigma*u2*v2);
					     //+on(1,3,u1=0) + on(2,4,u2=0);
varf b ([u1,u2], [v1,v2]) = int2d(Th)(u1*v1+u2*v2); //no boundary condition

matrix OP = op(Vh, Vh, solver=Crout, factorize=1); //crout solver because the matrix in not positive
matrix B = b(Vh, Vh, solver=CG, eps=1e-20);

// Solve
real[int] ev(nev); //to store the nev eigenvalue
//Vh[int] [eV1,eV2](nev); //to store the nev eigenvector
int k = EigenValue(OP, B, sym=true, sigma=sigma, value=ev, tol=1e-10, maxit=0, ncv=0);

// Display & Plot
for (int j = 0; j < k; j++){
cout << "lambda[" << j << "] = " << ev[j] << endl;
}
}