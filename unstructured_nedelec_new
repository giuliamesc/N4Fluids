// UNSTRUCTURED MESH, NEDELEC

ofstream file1("lambda3.dat");
int I = 6;
real [int] hvect (I);
real [int] error (I);

real a = 0;
real b = pi;

verbosity=0;
real sigma = 16; //value of the shift; this value avoids the 0 ones!
int nev = 30; //number of computed eigenvalue close to sigma
int i=2;

//for(int i=0; i<I; i++){
//Mesh
border l1(t=a,b){x=t;y=0;label=1;}
border l2(t=a,b){x=b;y=t;label=2;}
border l3(t=a,b){x=b-t;y=b;label=3;}
border l4(t=a,b){x=a;y=b-t;label=4;}
mesh Th=buildmesh(l1(2^(i+2))+l2(2^(i+2))+l3(2^(i+2))+l4(2^(i+2)));
plot(Th);
//Fespace
fespace Vh(Th,RT0Ortho);
Vh [u1,u2];
Vh [v1,v2];
fespace Qh(Th,P0);
Qh h = hTriangle;
hvect[i]= h[].max;
//Eigenvalue problem
// OP = A - sigma B ; // the shifted matrix
// Solve
int myN = 4;
for (int n = 0; n < myN; n++){
	for(int m = 0; m < myN; m++){
	int sigma = n*n + m*m;
	int nev = 1;
	real[int] ev(nev);
	varf op([u1,u2],[v1,v2])= int2d(Th)(dx(u2)*dx(v2)-dy(u1)*dx(v2)-dx(u2)*dy(v1)+dy(u1)*dy(v1)) 
						 -int2d(Th) (sigma*u1*v1+sigma*u2*v2)
					     +on(1,3,u1=0,u2=sin(n*y))+on(2,4,u1=sin(m*x),u2=0);

	varf bb ([u1,u2], [v1,v2]) = int2d(Th)(u1*v1+u2*v2);

	matrix OP = op(Vh, Vh, solver=Crout, factorize=1); //crout solver because the matrix in not positive
	matrix B = bb(Vh, Vh, solver=CG, eps=1e-20);

	int k = EigenValue(OP, B, sym=true, sigma=sigma, value=ev, tol=1e-10, maxit=0, ncv=0);
	cout << "lambda_exact = " << sigma << ";" << "lambda_computed = " << ev[0] << endl;
	file1 << ev << endl;
	}
}