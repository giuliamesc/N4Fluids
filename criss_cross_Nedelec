// CRISS-CROSS MESH, NEDELEC
ofstream file1("lambda1.dat");
int I = 6;
real [int] hvect (I);
real [int] error (I);

real x0 = 0;
real x1 = pi;
real y0 = 0;
real y1 = pi;

verbosity=0;
real sigma = 30; //value of the shift
int nev = 40; //number of computed eigen values near to sigma

for(int i=0; i<I; i++){
//Mesh
mesh Th = square(2^(i+2),2^(i+2),[x0+(x1-x0)*x, y0+(y1-y0)*y]);
plot(Th);
//Fespace
fespace Vh(Th,RT0Ortho);
Vh [u1,u2];
Vh [v1,v2];
fespace Qh(Th,P0);
Qh h = hTriangle;
hvect[i]= h[].max;
//Eigenvalue problem
// OP = A - sigma B ; // the shifted matrix
varf op([u1,u2],[v1,v2])= int2d(Th)(dx(u2)*dx(v2)-dy(u1)*dx(v2)-dx(u2)*dy(v1)+dy(u1)*dy(v1)) 
						 -int2d(Th) (sigma*u1*v1+sigma*u2*v2);
					     //+on(1,3,u1=0) + on(2,4,u2=0);
varf b ([u1,u2], [v1,v2]) = int2d(Th)(u1*v1+u2*v2); //no boundary condition

matrix OP = op(Vh, Vh, solver=Crout, factorize=1); //crout solver because the matrix in not positive
matrix B = b(Vh, Vh, solver=CG, eps=1e-20);

// Solve
real[int] ev(nev); //to store the nev eigenvalue
//Vh[int] [eV1,eV2](nev); //to store the nev eigenvector
int k = EigenValue(OP, B, sym=true, sigma=sigma, value=ev, tol=1e-10, maxit=0, ncv=0);

// Display & Plot
for (int j = 0; j < k; j++){
cout << "lambda[" << j << "] = " << ev[j] << endl;
if(i=I-1){file1 << ev[j] << endl;}
}
}
